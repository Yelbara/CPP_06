// CAST IN  C++:
    //TYPE  CAST  (EXPRESSION) ;
/*
    //static_cast 
    //dynamic_cast
    //const_cast
    //reinterpret_cast 
*/







/*------------------------------------STATIC_CAST------------------------------------------------------------*/
/*
//static_cast  :
        is an explicit cast that is allowed only when the compiler understands the conversion according to the C++ language rules.
        If the conversion is valid, the compiler allows it;
        if not, it produces a compile-time error.
#include <iostream>

struct Base {
    int x;
};


struct Derived : public Base {
    int y;
};


int main() {
    Base b;
    b.x = 10;

    Base* ptr = &b;

    Derived* d = static_cast<Derived*>(ptr);  
    /*
        work normall beacause: static_cast
        static_cast check in compile time only d is derived from Base so can be d point to ptr base with cast to derived.
        every thing is okay in compiler time in  static_cast also can make him in c++ is okay.
    --------------------------------------------------
        :::::>// but not always work beacause:
        ptr if point to Drived object. can make this beacause Derived is Base.
        and can make d point to ptr with static_cast. == d point to Derived object. every thing is okay.
                                !!!!
        but if ptr point to Base object and make d point to ptr.
        now d point to Base object but d is Derived type. so this is problem !!!!!.
        but static_cast not check this in compile time. 
        also check is rule in c++  this is what check :> (static_cast allows converting a Base* to a Derived* only because the types are related, not because the object is guaranteed to be Derived.) 
        okay so  evrything is okay but when run time make problem !!!.
        so when run time if access to d->y this is problem because d point to Base object not Derived object.
        so this is undefined behavior in c++.
    //--------------------------------------------------
        but why work this  d->y and give you garbage value .

        because compiler know d is Derived type.
        so compiler you know inside Derived have y member.
        so don't make error in compile time.
        but when run code want go to access to d->y. but d point to Base object not Derived object don't have y member so read memory not for y member.
        so this is undefined behavior in c++.
    */

    // std::cout << d->x << "\n";
    // std::cout << "------------\n";
    // std::cout << d->y << "\n"; 
    
// }

/*

-----------------------------------CONST_CATS-------------------------------------------------------------------------------------
// const_cast explanation for engineers:
            -------------
// 1️⃣ Purpose:
const_cast tells the compiler: "Treat this variable as if it is non-const (or add const)."
// It **only changes the type seen by the compiler**, not the memory itself.
// CPU still sees the same bits at the same address.

// 2️⃣ Memory and storage:
If the original variable is truly `const` and stored in **.rodata** (read-only data segment):
    - Writing through the const_cast pointer is **undefined behavior**.
    - Example: `const int x = 42; int* p = const_cast<int*>(&x); *p = 10;` → crash or memory corruption.

If the original variable is **non-const**, but you cast it to const or remove const:
    - Memory is **safe**, no UB.
    - Compiler just adjusts the type.
    - Example: 
      ```
      int y = 42;
      const int* pc = &y;             // add const
      int* p2 = const_cast<int*>(pc); // remove const
      *p2 = 100;                       // safe, memory exists and writable
      ```

// 3️⃣ Key point:
- **const is a compiler-only rule**.
- CPU/Memory does **not know** about const. It just sees **bits** at an **address**.
- `const_cast` affects only **compiler checks**, not the runtime memory directly.


+---------------------------+
|      Code Segment (.text) |  <- Instructions, functions (e.g., main, hello())
|                           |
+---------------------------+
|      Read-Only Data (.rodata) |
|      Global consts, string literals, other compiler-known read-only data |
|      e.g., const int g=42; const char* msg="Hello"; |
+---------------------------+
|      Data Segment (.data) |
|      Initialized global/static variables (non-const) |
|      e.g., int g2 = 100; static int s = 200; |
+---------------------------+
|      BSS Segment (.bss)   |
|      Uninitialized global/static variables |
|      e.g., int u; static int s2; |
+---------------------------+
|      Heap                 |
|      Dynamic memory (malloc/new) |
|      Can store const pointers or values (compiler enforces, CPU doesn't) |
+---------------------------+
|      Stack                |
|      Local variables, return addresses, saved registers |
|      Local const int x = 10; (compiler enforces) |
|      Not physically protected by OS (CPU reads/writes same) |
+---------------------------+


*/

/*--------------------------DYNAMIC_CAST------------------------------------------------------*/

/*
What INPUTS does __dynamic_cast receive? (PROOF)

From your assembly:

    mov     edx, OFFSET FLAT:typeinfo for Derived   ; target type
    mov     esi, OFFSET FLAT:typeinfo for Base      ; static type
    mov     rdi, rax                                ; ptr
    call    __dynamic_cast :> __dynamic_cast(ptr, typeinfo(Base), typeinfo(Derived));
    // That call exists because the compiler could not decide.
*/

// =======================================================
// ||||  COMPILER TIME BEHAVIOR of dynamic_cast
// =======================================================
//
// 1) The compiler checks that the source type is polymorphic
//    (i.e. it has at least one virtual function, so RTTI exists).
//
// 2) The compiler checks that the target type is related to the source
//    through inheritance.
//
// 3) The compiler checks that the cast form is valid
//    (e.g. pointer-to-pointer or reference-to-reference).
//
// If any of these checks fail, compilation fails.
//
// The compiler does NOT determine whether the cast will succeed.
// It cannot know the dynamic type of the object at compile time.
//
// Therefore, the compiler generates runtime code that calls __dynamic_cast.
// At runtime, __dynamic_cast inspects RTTI to verify the real object type.
// If the object is of the requested derived type, the cast succeeds.
// Otherwise, the result is nullptr (for pointer casts).
/*------------------------------------------------------------------------------------*/

// =======================================================
// ||||  RUN TIME BEHAVIOR of dynamic_cast
// =======================================================

// -------- VTABLE LAYOUT (Itanium ABI – GCC / Clang) --------
// VTABLE is NOT only virtual functions.
// It also stores RTTI metadata used by dynamic_cast.

// [0]  offset-to-top
// [1]  pointer to typeinfo object (RTTI)
// [2]  first virtual function
// [3]  second virtual function
// ...

// FIX:
// vptr does NOT point to [2]
// vptr points to the START of the vtable (index [0])


// =======================================================
// Step 1: Read object memory
// =======================================================

// ptr is Base* but points to a REAL object (maybe Derived)

// Memory layout:
// ptr ---> [ vptr ] [ Base subobject ] [ Derived subobject ]

// read *(ptr)
// inside *ptr have vptr = pointer stored at beginning of object
// vptr --> vtable of REAL dynamic type (Derived if object is Derived)


// =======================================================
// Step 2: Use vptr to access vtable
// =======================================================

// vptr[0] = offset-to-top :> (important for multiple inheritance)
// ADD:
// This value tells how many bytes we must subtract
// from ptr to reach the START of the COMPLETE object
// (important for multiple inheritance)


// =======================================================
// Step 3: Get RTTI (typeinfo) from vtable
// =======================================================

// vptr[1] = pointer to typeinfo structure

// FIX:
// This is NOT compile-time typeinfo(Base)
// This is RUNTIME typeinfo of the REAL object

// Example:
// If object is Derived:
// vptr[1] --> typeinfo(Derived)


// =======================================================
// Step 4: __dynamic_cast is called
// =======================================================

// Compiler generated code does something like:

// __dynamic_cast(
//     ptr,                   // pointer to object
//     &typeinfo(Base),       // static source type
//     &typeinfo(Derived),    // target type
//     offset                 // usually -1
// )


// =======================================================
// Step 5: __dynamic_cast runtime algorithm
// =======================================================

// 1) Read vptr from object
// 2) Use vptr[1] to get REAL typeinfo
// 3) Compare REAL typeinfo with target typeinfo(Derived)

// ADD:
// This comparison is NOT string-based
// It compares RTTI structures and inheritance graphs


// =======================================================
// Step 6: Check inheritance relationship
// =======================================================

// If REAL type == Derived
// OR REAL type derives from Derived
// OR can be safely converted → SUCCESS

// Else → FAIL (return nullptr)


// =======================================================
// Step 7: Pointer adjustment
// =======================================================

// If cast succeeds:
// Use offset-to-top (vptr[0])
// Adjust pointer so it points EXACTLY to Derived subobject

// This is why dynamic_cast works with:
// - multiple inheritance
// - virtual inheritance


// =======================================================
// Step 8: Final result
// =======================================================

// If success:
// Derived* d = adjusted pointer

// If failure:
// Derived* d = nullptr

/*-------------------------------REINTERPRET_CAST-----------------------------------------------------*/    
/*
    REINTERPRET_CAST: // Memory Reinterpretation 

    - Compiler Instruction: Tells the compiler to treat the memory bits of one type as another type.
      It does NOT create new memory or convert the value; it simply changes the "view" of the bits.

    - Memory Behavior: The same address in RAM is used. The CPU reads the bits according to the new type.
      Misuse can easily cause undefined behavior or crashes (e.g., misaligned pointer or incompatible type).

    - Differences from other casts:
        • Unlike static_cast: Does NOT check type compatibility at compile time.
        • Unlike dynamic_cast: Does NOT check runtime type, never returns nullptr.
        • Unlike const_cast: Does NOT change const-ness; only reinterpret bits.

    - Example mental model:
        char c = 'A';                  // 1 byte, 0x41
        int* p = reinterpret_cast<int*>(&c);  // same address, CPU will read 4 bytes as int
        *p = 0x12345678;               // modifies memory outside 'c', can crash

    - Use case: Low-level memory manipulation, hardware registers, interfacing with binary protocols, or type punning.
      Very unsafe if types don't match in memory layout.

    - Safety notes:
        • Ensure alignment is correct.
        • Ensure memory size is enough for new type.
        • Avoid casting across unrelated object hierarchies.

    - Summary: Powerful, no runtime or compile-time safety checks. You are responsible for correctness.
*/
